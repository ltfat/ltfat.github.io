 
<!DOCTYPE html>
<html lang="en">
<head class="include" file="../../include/header.html">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta NAME="keywords" CONTENT="gabor, wavelets, filterbank, signal processing, matlab,
octave"/>
<title>WPBEST - Best Tree selection</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.6.5/css/bootstrap-select.min.css">
<link rel="stylesheet" href="../../include/style.css" type="text/css">
<link rel="stylesheet" href="../../include/highlight.css" type="text/css">
</head>

<!-- body must stay hidden until all include parts are loaded -->
<body style="display:none;">
<!-- Wrap the content into responsive container --!>
<div class="container">
<!-- Include main navigation -->
<div class="masthead include" file="../../include/mainnav.html">
</div>
<div class="row">
    <div class="col-md-2" id="codeswitch"><div id="menutitle"><a href="wpbest.html">View the help</a></div>
</div>
    <div class="col-md-offset-5 col-md-5" id="jumplist">This is where navigation should be.</div>
</div>
<div class="row">
    <div class="col-md-2">
        <div class="include" file='../include/docnav.html'></div>
        <div id="seealso"><p></p></div>
    </div>
    <div class="col-md-10">

        <h1 class="title">WPBEST - Best Tree selection</h1>
<h2>Program code:</h2>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[c,info]<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wpbest</span><span class="p">(</span>f,w,J,varargin<span class="p">)</span><span class="w"></span>
<span class="c">%WPBEST  Best Tree selection</span><span class="w"></span>
<span class="c">%   Usage: c = wpbest(f,w,J,cost);</span><span class="w"></span>
<span class="c">%          [c,info] = wpbest(...);</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Input parameters:</span><span class="w"></span>
<span class="c">%         f   : Input data.</span><span class="w"></span>
<span class="c">%         w   : Wavelet Filterbank.</span><span class="w"></span>
<span class="c">%         J   : Maximum depth of the tree.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Output parameters:</span><span class="w"></span>
<span class="c">%         c     : Coefficients stored in a cell-array.</span><span class="w"></span>
<span class="c">%         info  : Transform parameters struct.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   [c,info]=WPBEST(f,w,J,cost) selects the best sub-tree info.wt from</span><span class="w"></span>
<span class="c">%   the full tree with max. depth J, which minimizes the cost function.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Only one-dimensional input f is accepted. The supported formats of</span><span class="w"></span>
<span class="c">%   the parameter w can be found in help for FWT. The format of the</span><span class="w"></span>
<span class="c">%   coefficients c and the info struct is the same as in WFBT.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Please note that w should define orthonormal wavelet filters.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   First, the depth J wavelet packet decomposition is performed using WPFBT.</span><span class="w"></span>
<span class="c">%   Then the nodes are traversed in the breadth-first and bottom-up order</span><span class="w"></span>
<span class="c">%   and the value of the cost function of the node input and cost of the</span><span class="w"></span>
<span class="c">%   combined node outputs is compared. If the node input cost function value</span><span class="w"></span>
<span class="c">%   is less than the combined output cost, the current node and all</span><span class="w"></span>
<span class="c">%   possible descendant nodes are marked to be deleted, if not, the input is</span><span class="w"></span>
<span class="c">%   assigned the combined output cost. At the end, the marked nodes are</span><span class="w"></span>
<span class="c">%   removed and the resulting tree is considered to be a best basis (or</span><span class="w"></span>
<span class="c">%   near-best basis) in the chosen cost function sense.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   The cost parameter can be a cell array or an user-defined function handle.</span><span class="w"></span>
<span class="c">%   accepting a single column vector. The cell array should consist of a</span><span class="w"></span>
<span class="c">%   string, followed by a numerical arguments.</span><span class="w"></span>
<span class="c">%   The possible formats are listed in the following text.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Additive costs:</span><span class="w"></span>
<span class="c">%   ---------------</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   The additive cost E of a vector x is a real valued cost function</span><span class="w"></span>
<span class="c">%   such that:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   ..</span><span class="w"></span>
<span class="c">%      E(x) = sum E(x(k)),</span><span class="w"></span>
<span class="c">%              k</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   and E(0)=0. Given a collection of vectors x_i being coefficients in</span><span class="w"></span>
<span class="c">%   orthonormal bases B_i, the best basis relative to E is the one for</span><span class="w"></span>
<span class="c">%   which the E(x_i) is minimal.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Additive cost functions allows using the fast best-basis search algorithm</span><span class="w"></span>
<span class="c">%   since the costs can be precomputed and combined cost of two vectors is</span><span class="w"></span>
<span class="c">%   just a sum of their costs.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;shannon&#39;}</span><span class="w"></span>
<span class="c">%      A cost function derived from the Shannon entropy:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_sh(x) = -sum |x(k)|^2 log(|x(k)|^2),</span><span class="w"></span>
<span class="c">%                 k:x(k)~=0</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;log&#39;}</span><span class="w"></span>
<span class="c">%      A logarithm of energy:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_log(x) = sum log(|x(k)|^2),</span><span class="w"></span>
<span class="c">%                  k:x(k)~=0</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;lpnorm&#39;,p}</span><span class="w"></span>
<span class="c">%      Concentration in l^p norm:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_lp(x) = ( sum (|x(k)|^p) ),</span><span class="w"></span>
<span class="c">%                      k</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;thre&#39;,th}</span><span class="w"></span>
<span class="c">%      Number of coefficients above a threshold th.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Non-additive costs:</span><span class="w"></span>
<span class="c">%   -------------------</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Cost function, which is not additive cost but which is used for the</span><span class="w"></span>
<span class="c">%   basis selection is called a non-additive cost. The resulting basis for</span><span class="w"></span>
<span class="c">%   which the cost is minimal is called near-best, because the non-additive</span><span class="w"></span>
<span class="c">%   cost cannot guarantee the selection of a best basis relative to the</span><span class="w"></span>
<span class="c">%   cost function.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;wlpnorm&#39;,p}</span><span class="w"></span>
<span class="c">%      The weak-l^p norm cost function:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_wlp(x) = max k^{\frac{1}{p}}v_k(x),</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      where 0&lt;p&lt;= 2 and v_k(x) denotes the k*-th largest absolute value</span><span class="w"></span>
<span class="c">%      of x.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;compn&#39;,p,f}</span><span class="w"></span>
<span class="c">%      Compression number cost:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_cn(x) = arg min |w_k(x,p) - f|,</span><span class="w"></span>
<span class="c">%                     k</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      where 0&lt;p&lt;= 2, 0&lt;f&lt;1 and w_k(u,p) denotes decreasingly sorted,</span><span class="w"></span>
<span class="c">%      powered, cumulateively summed and renormalized vector:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%                     k              N</span><span class="w"></span>
<span class="c">%         w_k(x,p) = sum v_j^p(x) / sum v_j^p(x)</span><span class="w"></span>
<span class="c">%                    j=1            j=1</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      where v_k(x) denotes the k*-th largest absolute value of x and</span><span class="w"></span>
<span class="c">%      N is the number of elements of x.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   {&#39;compa&#39;,p}</span><span class="w"></span>
<span class="c">%      Compression area cost:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      ..</span><span class="w"></span>
<span class="c">%         E_ca(x) = N - sum w_k(x,p),</span><span class="w"></span>
<span class="c">%                        k</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%      where 0&lt;p&lt;= 2 and w_k(u,p) and N as in the previous case.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Examples:</span><span class="w"></span>
<span class="c">%   ---------</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   A simple example of calling WPBEST :</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%     f = gspi;</span><span class="w"></span>
<span class="c">%     J = 8;</span><span class="w"></span>
<span class="c">%     [c,info] = wpbest(f,&#39;sym10&#39;,J,&#39;cost&#39;,&#39;shannon&#39;);</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%     % Use 2/3 of the space for the first plot, 1/3 for the second.</span><span class="w"></span>
<span class="c">%     subplot(3,3,[1 2 4 5 7 8]);</span><span class="w"></span>
<span class="c">%     plotwavelets(c,info,44100,90);</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%     subplot(3,3,[3 6 9]);</span><span class="w"></span>
<span class="c">%     N=cellfun(@numel,c); L=sum(N); a=L./N;</span><span class="w"></span>
<span class="c">%     plot(a,&#39;o&#39;);</span><span class="w"></span>
<span class="c">%     xlim([1,numel(N)]);</span><span class="w"></span>
<span class="c">%     view(90,-90);</span><span class="w"></span>
<span class="c">%     xlabel(&#39;Channel no.&#39;);</span><span class="w"></span>
<span class="c">%     ylabel(&#39;Subsampling rate / samples&#39;);</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   References:</span><span class="w"></span>
<span class="c">%     M. V. Wickerhauser. Lectures on wavelet packet algorithms. In INRIA</span><span class="w"></span>
<span class="c">%     Lecture notes. Citeseer, 1991.</span><span class="w"></span>
<span class="c">%     </span><span class="w"></span>
<span class="c">%     C. Taswell. Near-best basis selection algorithms with non-additive</span><span class="w"></span>
<span class="c">%     information cost functions. In Proceedings of the IEEE International</span><span class="w"></span>
<span class="c">%     Symposium on Time-Frequency and Time-Scale Analysis, pages 13--16. IEEE</span><span class="w"></span>
<span class="c">%     Press, 1994.</span><span class="w"></span>
<span class="c">%     </span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   Url: http://ltfat.github.io/doc/wavelets/wpbest.html</span><span class="w"></span>

<span class="c">% Copyright (C) 2005-2023 Peter L. Soendergaard &lt;peter@sonderport.dk&gt; and others.</span><span class="w"></span>
<span class="c">% This file is part of LTFAT version 2.6.0</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% This program is free software: you can redistribute it and/or modify</span><span class="w"></span>
<span class="c">% it under the terms of the GNU General Public License as published by</span><span class="w"></span>
<span class="c">% the Free Software Foundation, either version 3 of the License, or</span><span class="w"></span>
<span class="c">% (at your option) any later version.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% This program is distributed in the hope that it will be useful,</span><span class="w"></span>
<span class="c">% but WITHOUT ANY WARRANTY; without even the implied warranty of</span><span class="w"></span>
<span class="c">% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><span class="w"></span>
<span class="c">% GNU General Public License for more details.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% You should have received a copy of the GNU General Public License</span><span class="w"></span>
<span class="c">% along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span><span class="w"></span>

<span class="c">% AUTHOR: Zdenek Prusa</span><span class="w"></span>

<span class="n">complainif_notenoughargs</span><span class="p">(</span><span class="nb">nargin</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;WPBEST&#39;</span><span class="p">);</span><span class="w"></span>
<span class="n">complainif_notposint</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;WPBEST&#39;</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="nb">nonzeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">1</span><span class="w"></span>
<span class="w">   </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;%s: Function accepts only single channel inputs.&#39;</span><span class="p">,</span><span class="nb">upper</span><span class="p">(</span><span class="nb">mfilename</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="n">definput</span><span class="p">.</span><span class="n">import</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="s">&#39;fwt&#39;</span><span class="p">,</span><span class="s">&#39;wfbtcommon&#39;</span><span class="p">};</span><span class="w"></span>
<span class="n">definput</span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">buildOrder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="s">&#39;bottomup&#39;</span><span class="p">,</span><span class="s">&#39;topdown&#39;</span><span class="p">};</span><span class="w"></span>
<span class="n">definput</span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">bestWhat</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="s">&#39;tree&#39;</span><span class="p">,</span><span class="s">&#39;level&#39;</span><span class="p">};</span><span class="w"></span>
<span class="n">definput</span><span class="p">.</span><span class="n">keyvals</span><span class="p">.</span><span class="n">cost</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="s">&#39;shannon&#39;</span><span class="p">};</span><span class="w"></span>
<span class="p">[</span><span class="n">flags</span><span class="p">,</span><span class="n">kv</span><span class="p">]=</span><span class="n">ltfatarghelper</span><span class="p">({</span><span class="s">&#39;cost&#39;</span><span class="p">},</span><span class="n">definput</span><span class="p">,</span><span class="nb">varargin</span><span class="p">);</span><span class="w"></span>


<span class="k">if</span><span class="w"> </span><span class="n">flags</span><span class="p">.</span><span class="n">do_topdown</span><span class="w"></span>
<span class="w">    </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;%s: Flag %s not supported yet.&#39;</span><span class="p">,</span><span class="nb">upper</span><span class="p">(</span><span class="nb">mfilename</span><span class="p">),</span><span class="n">flags</span><span class="p">.</span><span class="n">buildOrder</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="n">flags</span><span class="p">.</span><span class="n">do_level</span><span class="w"></span>
<span class="w">    </span><span class="nb">error</span><span class="p">(</span><span class="s">&#39;%s: Flag %s not supported yet.&#39;</span><span class="p">,</span><span class="nb">upper</span><span class="p">(</span><span class="nb">mfilename</span><span class="p">),</span><span class="n">flags</span><span class="p">.</span><span class="n">bestWhat</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="p">(</span><span class="o">~</span><span class="nb">iscell</span><span class="p">(</span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="p">))</span><span class="w"></span>
<span class="w">   </span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="p">};</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% test if the chosen entropy measure is additive</span><span class="w"></span>
<span class="n">do_additive</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">isAdditive</span><span class="p">(</span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">do_bottomup</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="c">% Do full-tree Wavelet Packet decomposition beforehand and prune.</span><span class="w"></span>
<span class="w">   </span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">info</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wpfbt</span><span class="p">(</span><span class="n">setnorm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s">&#39;2&#39;</span><span class="p">),{</span><span class="n">w</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="s">&#39;full&#39;</span><span class="p">},</span><span class="s">&#39;nat&#39;</span><span class="p">,</span><span class="n">flags</span><span class="p">.</span><span class="n">ext</span><span class="p">,</span><span class="s">&#39;intnoscale&#39;</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c">% Nodes in the reverse BF order</span><span class="w"></span>
<span class="w">   </span><span class="n">treePath</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fliplr</span><span class="p">(</span><span class="n">nodeBForder</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">wt</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c">% Relationships between nodes</span><span class="w"></span>
<span class="w">   </span><span class="p">[</span><span class="n">pOutIdxs</span><span class="p">,</span><span class="n">chOutIdxs</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">treeWpBFrange</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">wt</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="c">% Nodes to be removed</span><span class="w"></span>
<span class="w">   </span><span class="n">removeNodes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>

<span class="w">   </span><span class="c">% Energy normalization</span><span class="w"></span>
<span class="w">   </span><span class="c">% totalE = sum(cellfun(@(cEl) sum(cEl.^2),c));</span><span class="w"></span>
<span class="w">   </span><span class="c">% c = cellfun(@(cEl) cEl.^2/totalE,c,&#39;UniformOutput&#39;,0);</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="c">% pre-calculate entropy of all subbands</span><span class="w"></span>
<span class="w">   </span><span class="n">cEnt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cellfun</span><span class="p">(@(</span><span class="n">cEl</span><span class="p">)</span><span class="w"> </span><span class="n">wcostwrap</span><span class="p">(</span><span class="n">cEl</span><span class="p">,</span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">do_additive</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">pOutIdxs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">pEnt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cEnt</span><span class="p">(</span><span class="n">pOutIdxs</span><span class="p">(</span><span class="n">ii</span><span class="p">));</span><span class="w"></span>
<span class="w">          </span><span class="n">chEnt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">cEnt</span><span class="p">(</span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">ii</span><span class="p">}));</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="n">pEnt</span><span class="o">&lt;=</span><span class="n">chEnt</span><span class="w"></span>
<span class="w">             </span><span class="n">removeNodes</span><span class="p">(</span><span class="k">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">treePath</span><span class="p">(</span><span class="n">ii</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">             </span><span class="c">% Set parent entropy to the sum of the children entropy.</span><span class="w"></span>
<span class="w">             </span><span class="n">cEnt</span><span class="p">(</span><span class="n">pOutIdxs</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">chEnt</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">end</span><span class="w"></span>
<span class="w">       </span><span class="k">end</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">pOutIdxs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">pEnt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cEnt</span><span class="p">(</span><span class="n">pOutIdxs</span><span class="p">(</span><span class="n">ii</span><span class="p">));</span><span class="w"></span>
<span class="w">          </span><span class="n">chEnt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wcostwrap</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">ii</span><span class="p">}),</span><span class="n">kv</span><span class="p">.</span><span class="n">cost</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="c">% Set parent entropy to value obtanied by concatenating child</span><span class="w"></span>
<span class="w">          </span><span class="c">% subbands.</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">pEnt</span><span class="o">&lt;=</span><span class="n">chEnt</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="n">removeNodes</span><span class="p">(</span><span class="k">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">treePath</span><span class="p">(</span><span class="n">ii</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">             </span><span class="c">% Search the pOutIdxs(ii) in chOutIdxs</span><span class="w"></span>
<span class="w">             </span><span class="c">% There should be the only one..</span><span class="w"></span>
<span class="w">             </span><span class="n">foundId</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cellfun</span><span class="p">(@(</span><span class="n">chEl</span><span class="p">)</span><span class="nb">find</span><span class="p">(</span><span class="n">chEl</span><span class="o">==</span><span class="n">pOutIdxs</span><span class="p">(</span><span class="n">ii</span><span class="p">)),</span><span class="n">chOutIdxs</span><span class="p">,</span><span class="k">...</span><span class="w"></span>
<span class="w">                               </span><span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">             </span><span class="n">chId</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">find</span><span class="p">(</span><span class="o">~</span><span class="nb">cellfun</span><span class="p">(@</span><span class="nb">isempty</span><span class="p">,</span><span class="n">foundId</span><span class="p">));</span><span class="w"></span>
<span class="w">             </span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">chId</span><span class="p">}(</span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">chId</span><span class="p">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pOutIdxs</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="w">             </span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">chId</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">chId</span><span class="p">},</span><span class="n">chOutIdxs</span><span class="p">{</span><span class="n">ii</span><span class="p">}];</span><span class="w"></span>
<span class="w">          </span><span class="k">end</span><span class="w"></span>

<span class="w">       </span><span class="k">end</span><span class="w"></span>
<span class="w">   </span><span class="k">end</span><span class="w"></span>


<span class="w">   </span><span class="c">% Do tree prunning.</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">removeNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">[</span><span class="n">info</span><span class="p">.</span><span class="n">wt</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">nodeSubtreeDelete</span><span class="p">(</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span><span class="n">info</span><span class="p">.</span><span class="n">wt</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="c">% Finally do the analysis using the created best tree. with correct</span><span class="w"></span>
<span class="c">% frequency bands order</span><span class="w"></span>
<span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">info</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wfbt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">wt</span><span class="p">,</span><span class="n">flags</span><span class="p">.</span><span class="n">ext</span><span class="p">,</span><span class="n">flags</span><span class="p">.</span><span class="n">forder</span><span class="p">);</span><span class="w"></span>
<span class="c">%END WPBEST</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>ad<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">isAdditive</span><span class="p">(</span>entFunc<span class="p">)</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="c">%x = x./norm(x);</span><span class="w"></span>
<span class="n">ent1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wcostwrap</span><span class="p">(</span><span class="n">x</span><span class="o">&#39;</span><span class="p">,</span><span class="n">entFunc</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">ent2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="nb">arrayfun</span><span class="p">(@(</span><span class="n">xEl</span><span class="p">)</span><span class="w"> </span><span class="n">wcostwrap</span><span class="p">(</span><span class="n">xEl</span><span class="p">,</span><span class="n">entFunc</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="n">ad</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ent1</span><span class="o">==</span><span class="n">ent2</span><span class="p">;</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcostwrap</span><span class="p">(</span>x,fname,do_normalization<span class="p">)</span><span class="w"></span>
<span class="c">%WENTWRAP Entropy functions wrapper</span><span class="w"></span>
<span class="c">%   Usage:  E = wentwrap(x,fname,varargin)</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%   `E = wentwrap(x,fname,varargin)` passes given parameters further to the</span><span class="w"></span>
<span class="c">%   appropriate function.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">iscell</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell2mat</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="n">do_normalization</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="o">./</span><span class="nb">norm</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">isa</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">&#39;function_handle&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">fname</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="w"></span>
<span class="w">   </span><span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">feval</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s">&#39;%s%s&#39;</span><span class="p">,</span><span class="s">&#39;wcost_&#39;</span><span class="p">,</span><span class="n">fname</span><span class="p">{</span><span class="mi">1</span><span class="p">}),</span><span class="n">x</span><span class="p">,</span><span class="n">fname</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">});</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="w">   </span><span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">feval</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s">&#39;%s%s&#39;</span><span class="p">,</span><span class="s">&#39;wcost_&#39;</span><span class="p">,</span><span class="n">fname</span><span class="p">{</span><span class="mi">1</span><span class="p">}),</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">% ADDITIVE COSTS %</span><span class="w"></span>
<span class="c">%%%%%%%%%%%%%%%%%%</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_shannon</span><span class="p">(</span>x<span class="p">)</span><span class="w"></span>
<span class="c">% Cost function derived from the Shannon-Weaver entropy.</span><span class="w"></span>

<span class="n">u</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="o">~=</span><span class="mi">0</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="o">.*</span><span class="nb">log</span><span class="p">(</span><span class="n">u</span><span class="p">));</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_log</span><span class="p">(</span>x<span class="p">)</span><span class="w"></span>
<span class="c">% Logarithm of energy.</span><span class="w"></span>
<span class="c">% It may be interpreted as the entropy of a Gauss-Markov process, composed</span><span class="w"></span>
<span class="c">% of numel(x) uncorrelated Gaussian random variables of variences</span><span class="w"></span>
<span class="c">% x(1),..,x(end). Minimizing the function finds the best approximation to</span><span class="w"></span>
<span class="c">% the Karhuen-lo√©ve basis for the process.</span><span class="w"></span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="o">~=</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="n">x</span><span class="p">(:)</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_thre</span><span class="p">(</span>x,th<span class="p">)</span><span class="w"></span>
<span class="c">% Number of coefficients above a treshold.</span><span class="w"></span>
<span class="c">% It gives a number of coefficients needed to transimt the signal to</span><span class="w"></span>
<span class="c">% precision th.</span><span class="w"></span>

<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="n">th</span><span class="p">));</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_lpnorm</span><span class="p">(</span>x,p<span class="p">)</span><span class="w"></span>
<span class="c">% Concentration in l^p norm, p&lt;2</span><span class="w"></span>
<span class="c">% The smaller is the l^p norm of a signal with l^2 equal to 1, the more</span><span class="w"></span>
<span class="c">% concentrated is its energy into a few coefficients.</span><span class="w"></span>
<span class="nb">assert</span><span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">p</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;%s: Parameter p have to be in the range ]0,2[&#39;</span><span class="p">,</span><span class="nb">upper</span><span class="p">(</span><span class="nb">mfilename</span><span class="p">));</span><span class="w"></span>
<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(:))</span><span class="o">.^</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">% NON-ADDITIVE COSTS %</span><span class="w"></span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_wlpnorm</span><span class="p">(</span>x,p<span class="p">)</span><span class="w"></span>
<span class="c">% Weak Lp-norm</span><span class="w"></span>

<span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(:)),</span><span class="s">&#39;descend&#39;</span><span class="p">);</span><span class="w"></span>

<span class="n">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">((</span><span class="n">k</span><span class="p">.</span><span class="o">&#39;.^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span><span class="o">.*</span><span class="n">v</span><span class="p">);</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_compa</span><span class="p">(</span>x,p<span class="p">)</span><span class="w"></span>
<span class="c">% Compresion Area Entropy, p&lt;2</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>

<span class="c">% 0&lt;p&lt;=2</span><span class="w"></span>
<span class="nb">assert</span><span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">p</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;Parameter p have to be in the range ]0,2]&#39;</span><span class="p">);</span><span class="w"></span>
<span class="n">N</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="c">%u = x./norm(x);</span><span class="w"></span>
<span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(:)),</span><span class="s">&#39;descend&#39;</span><span class="p">);</span><span class="w"></span>

<span class="n">wnom</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cumsum</span><span class="p">(</span><span class="n">v</span><span class="o">.^</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="n">w</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wnom</span><span class="o">./</span><span class="n">wnom</span><span class="p">(</span><span class="k">end</span><span class="p">);</span><span class="w"></span>

<span class="n">E</span><span class="p">=</span><span class="n">N</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w"></span>

<span class="k">function</span><span class="w"> </span>E<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">wcost_compn</span><span class="p">(</span>x,p,f<span class="p">)</span><span class="w"></span>
<span class="c">% Compresion Number entropy</span><span class="w"></span>
<span class="c">% Represents a minimum number of coefficients containing 100*f% of the total</span><span class="w"></span>
<span class="c">% p norm of x.</span><span class="w"></span>


<span class="c">% 0&lt;p&lt;=2</span><span class="w"></span>
<span class="nb">assert</span><span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">p</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;Parameter p have to be in the range ]0,2]&#39;</span><span class="p">);</span><span class="w"></span>
<span class="nb">assert</span><span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">f</span><span class="o">&amp;&amp;</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;Parameter f  have to be in the range ]0,1[&#39;</span><span class="p">);</span><span class="w"></span>

<span class="c">%u = x./norm(x);</span><span class="w"></span>
<span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(:)),</span><span class="s">&#39;descend&#39;</span><span class="p">);</span><span class="w"></span>

<span class="n">wnom</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cumsum</span><span class="p">(</span><span class="n">v</span><span class="o">.^</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="n">w</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wnom</span><span class="o">./</span><span class="n">wnom</span><span class="p">(</span><span class="k">end</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="n">E</span><span class="p">]=</span><span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="n">f</span><span class="p">));</span><span class="w"></span>
</pre></div>


        <div class="include" file="../../include/footer.html"></div>
    </div>
</div>
<!-- These two have to be here to dynamically load the included parts -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script
src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.6.5/js/bootstrap-select.min.js"></script>
<script src="../../js/ltfat.js" type="text/javascript"></script>
<script src="../include/lookup.js" type="text/javascript"></script>
<script src="../include/jumplist.js" type="text/javascript"></script>
</body>
</html>

